{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"to",
				"totalProcessCounter"
			],
			[
				"read",
				"read_from_pipe"
			],
			[
				"writ",
				"write_to_pipe"
			],
			[
				"EXIT",
				"EXIT_FAILURE"
			],
			[
				"sh",
				"SHFLAG"
			],
			[
				"con",
				"consoleOP"
			],
			[
				"pare",
				"parentPID"
			],
			[
				"parent",
				"parentPID"
			],
			[
				"nopr",
				"noprocessop"
			],
			[
				"kil",
				"killprocessop"
			],
			[
				"TIM",
				"timeStr"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "#include <stdio.h>   /* printf, stderr, fprintf */\n#include <sys/types.h> /* pid_t */\n#include <unistd.h>  /* _exit, fork */\n#include <stdlib.h>  /* exit */\n#include <errno.h>   /* errno */\n#include <string.h>\n#include <time.h>\n#include <sys/types.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <sys/ioctl.h>\n#include \"memwatch.h\"\n\nvoid genericOP(char* data);\nvoid consoleOP(char* data);\nvoid killProcessOP(int signum);\nvoid pidKilledOP(char * pidval, char * appdata, char * timeStr);\nvoid noProcessOP(char * appdata);\nvoid initProcOP(char * appdata, char * pidval );\nvoid deleteProcnannies();\nvoid getParentPID();\nvoid initialisationOP();\nvoid write_to_pipe(int file, char * data);\nvoid read_from_pipe(int file);\n\n#define READ 0\n#define WRITE 1 \n\nstatic int parentPID; \nstatic int SHFLAG = 0;\n\nstatic void catch_function(int signo) {\n	// if get_pid() is equal to the global variable (parent)\n	// then hangup\n	// if not ignore \n	puts(\"At this point you should kill all child processes... \");\n	exit(EXIT_FAILURE);\n}\n\nstatic void ignore_function(int signo ) { \n	puts(\"Hangup!\");\n	printf(\"Parent ID Recognised: %d\\n\", parentPID);\n	SHFLAG = 1;\n	printf(\"SHFLAG: %d\\n\", SHFLAG);\n	\n	/*\n	\"you cant pass anything thru here :( \"\n	\"so you have to put the polling in the main funciton, not here. .... . .\"\n	\"only things you can manipulate thru here are globals \"\n	\"make everyrhing a global? :o flags? \"\n	\"my wait statement is wait(&status) ... it doesnt work now LOL\"\n	\" i have to set polling status on that instead, and check on the flag change? to reread the file?\"\n\n	\"ALSO! if i reread the file do i add all the new processes ? that means that i have to do comparators vs. all\"\n	\" of the func names right? ><'' \"\n	\"that means that if you wanted to monitor a diplicate process you couldnt do so (w/ different pid)... is that \"\n	\"the corrrect processs flow?\"\n\n	\"you keep track of the process ids that you're currently monitoring and if \"\n	\"you reread the config file you recheck all proceses - if the process is in the list of already monitored processes, you\"\n	\"skip to the next one \"\n	\"also check every 5s via <<pipe>>\"\n	*/\n}\n\nint main(int c, char *argv[]) {\n	// pgrep other procnannies applications ... \n	// for each one, if it's not your current pid, kill process\n	// there's a key combination which sends a hangup \n	/* DO THIS AT THE BEGINNING OF THE ASSIGNMENT*/\n	if (signal(SIGINT, catch_function) == SIG_ERR) {\n    fputs(\"An error occurred while setting a signal handler.\\n\", stderr);\n    return EXIT_FAILURE;\n  }\n\n	deleteProcnannies();\n	getParentPID();\n	initialisationOP();\n	\n	const char* s = getenv(\"PROCNANNYLOGS\"); \n	FILE* logfile = fopen(s, \"w\");\n	fclose(logfile);   \n\n	FILE* file = fopen ( argv[1], \"r\" );\n\n	if (file == NULL) {\n		printf(\"ERROR: Nanny.config file presented was not found. Program exiting...\");\n		exit(EXIT_FAILURE);  \n	}\n\n	int counter = 0;\n	char test[280][1000]; //array of strings //length is 10! figure out how to realloc!\n	char appdata[280][1000];\n	int timedata[280];\n	char * pch; \n	int countval = 0;\n\n	if (file != NULL) {\n		char line[100];\n		while (fgets(line, sizeof line, file) != NULL) { /* read a line from a file */\n			// reads sample text: testa 120\n			strcpy(test[counter - 1], strtok(line, \"\\n\"));\n			pch = strtok (test[counter-1],\" ,.-\");\n			while (pch != NULL) {\n				if (countval == 0) {\n					strcpy(appdata[counter], pch);\n					countval++;\n				} else if (countval == 1) {\n					timedata[counter] = atoi(pch);\n					countval = 0;\n					break;\n				}\n				pch = strtok (NULL, \" ,.-\");\n			}\n			counter++;\n		}\n	}\n	fclose(file);\n\n	FILE* f[counter - 1];\n	int i;\n	int totalProcessCounter = 0;\n	pid_t pid; \n	int fd[counter][2];\n\n\n	for (i = 0; i < counter; i++) {\n		if (appdata[i][0] != '\\0') { \n			//printf(\"Application Testing: %s\\n\", test[i]);\n			char grepip[1000];\n			strcpy(grepip, \"pgrep \");\n			strcat(grepip, appdata[i]);\n			if ( ( f[i] = popen( grepip, \"r\" ) ) == NULL ) {\n				perror( \"popen\" );\n			} else {\n				char pidval[150];\n				pid_t pidint;\n				int haspid = 0;\n\n				if (pipe(fd[i]) < 0) {\n					printf(\"ERROR: ProcNanny cannot create pipe. Program exiting...\");\n					exit(EXIT_FAILURE); \n				}\n	\n				while (fgets(pidval, 150, f[i]) != NULL) {\n					haspid = 1;\n					pid = fork();\n					if (pid < 0) { // error process\n				 		fprintf(stderr, \"can't fork, error %d\\n\", errno);\n						exit(EXIT_FAILURE);\n					} else if (pid > 0) { // parent process\n						close(fd[i][WRITE]);\n						totalProcessCounter = totalProcessCounter + 1;;\n						 // fd[i][0] needs to read the child kill process.\n					} else if (pid == 0 ) { // child process\n						close(fd[i][READ]); // fd[i][1] needs to write the child kill process.\n						strtok(pidval, \"\\n\");\n						initProcOP(appdata[i], pidval);\n\n						pidint = (pid_t) strtol(pidval, NULL, 10);\n						int sleepLeft = timedata[i];\n						while(sleepLeft > 0) {\n							printf(\"Process %s is running with %d seconds left.\\n\", pidval, sleepLeft);\n							\n							sleep(5);\n							sleepLeft = sleepLeft - 5;\n						}\n						char timeStr[30];\n						sprintf(timeStr, \"%d\", timedata[i]);\n						int killresult = kill(pidint, SIGKILL);\n							if (killresult == 0) {\n								//printf(\"You killed the process (PID: %d) (Application: %s)\\n\", pidint, test[i] );\n								pidKilledOP(pidval, appdata[i], timeStr);\n							} else if (killresult == -1) {\n								//printf(\"ERROR: Process already killed (PID: %d) (Application: %s)\\n\", pidint, test[i] );\n							}\n							consoleOP(\"Process monitoring complete.\");\n							write_to_pipe(fd[i][WRITE], \"APP DONE\\n\");\n							//write(fd[i][1], &n, sizeof(n));\n							exit(EXIT_SUCCESS); \n						} \n					}\n					if (haspid == 0) {\n					//printf(\"No processes found for %s.\\n\", test[i]);\n					noProcessOP(appdata[i]);\n				}		\n			}\n			pclose(f[i]);\n			close(fd[i][0]);\n			close(fd[i][1]);\n		}\n	}	\n\n	// if hangup signal is presented, reread the config and print output\n	// * don't do anything yet.\n	// kill -1 PIDVAL\n  if (signal(SIGHUP, ignore_function) == SIG_ERR) {\n		/*\n		consoleOP(\"Info: Caught SIGHUP. Configuration file 'nanny.config' re-read.\");    \n    file = fopen ( argv[1], \"r\" );\n\n		if (file != NULL) {\n			char line [1000];\n			while (fgets(line, sizeof line, file) != NULL) { // read a line from a file \n				// reads sample text: testa 120\n				strcpy(test[counter - 1], strtok(line, \"\\n\"));\n				pch = strtok (test[counter-1],\" ,.-\");\n				while (pch != NULL) {\n					if (countval == 0) {\n						strcpy(appdata[counter], pch);\n						countval++;\n					} else if (countval == 1) {\n						timedata[counter] = atoi(pch);\n						countval = 0;\n						break;\n					}\n					pch = strtok (NULL, \" ,.-\");\n				}\n				counter++;\n			}\n		}\n		fclose(file);\n		*/\n  }\n\n	//printf(\"Total processes monitored: %d\\n\", totalProcessCounter);\n	int k; \n	int status;\n	int signum = 0;\n 	\n 	/*\n	for (k = 0; k < totalProcessCounter; k++) {\n		while (read(fd[l][0], line, 100) != NULL) {}\n		// up or down\n		int clearBuf = 99999;\n		clearBuf = read(fd[l][0], line, 100);\n		printf(\"CLEARBUF VALUE IS : %d\", clearBuf);\n		\n	}*/\n	/*\n	for (k = 0; k < totalProcessCounter; k++) {\n		while(1) {\n			for (l = 0; l < totalProcessCounter; l++) {\n				int n = 99999;\n				n = read(fd[l][0], line, 100);\n				if (n != 99999) {\n					printf(\"This is n: %d\\n\", n);\n				}\n				if (n == -1) {\n					printf(\"oh god we're using gotos.\\n\");\n					goto iteratenextloop;\n				}\n			}\n		}\n		iteratenextloop: ;\n	}*/\n\n	char *buff = NULL;\n  char byte = 0;\n  int count = 0;\n 	\n	for (k = 0; k < totalProcessCounter; k++) {\n		wait(&status);\n		while (read(fd[k][READ], &byte, 1) == 1) {\n			printf(\"sadface\");\n      if (ioctl(fd[k][READ], FIONREAD, &count) != -1) {\n      	buff = malloc(count+1);\n        buff[0] = byte;\n        if (read(fd[k][READ], buff+1, count) == count) {\n          fprintf(stdout,\"Child: received \\\"%s\\\"\\n\", buff);\n          free(buff);\n        } else {\n        }\n      }\n    }\n		printf(\"Status value: %d\\n\", status);\n		if(status == 0) {\n			signum = signum + 1;\n		}\n	}\n\n	for (k = 0; k < totalProcessCounter; k++) {\n		close(fd[k][0]);\n		close(fd[k][1]);\n	}\n	\n	killProcessOP(signum);\n	consoleOP(\"*operations have concluded for this process (all iterations have gone through).*\");\n	return 0;\n}\n\nvoid write_to_pipe (int file, char* data)\n{\n  FILE *stream;\n  stream = fdopen (file, \"w\");\n  fprintf (stream, \"%s\", data);\n  fclose (stream);\n}\n\nvoid read_from_pipe (int file)\n{\n  FILE *stream;\n  int c;\n  stream = fdopen (file, \"r\");\n  while ((c = fgetc (stream)) != EOF)\n    putchar (c);\n  fclose (stream);\n}\n\nvoid deleteProcnannies() {\n		FILE * pnfile;\n		pid_t curpid;\n		curpid = getpid();\n		if ( ( pnfile = popen(\"pgrep procnanny\", \"r\" ) ) == NULL ) {\n				perror( \"popen\" );\n		} else { \n			pid_t pidpn;\n			char pidbuffer[30];\n			while (fgets(pidbuffer, 150, pnfile) != NULL) {\n				pidpn = (pid_t) strtol(pidbuffer, NULL, 10);\n				// if pid is not the one you currently opened...\n				if (pidpn != curpid) {\n					kill(pidpn, SIGKILL);\n				}\n			}\n		}\n		fclose(pnfile); \n		return;\n}\n\nvoid genericOP(char* data) {\n		const char* s = getenv(\"PROCNANNYLOGS\");\n		FILE* file= fopen (s, \"a\" );\n		time_t ltime;\n		time(&ltime); \n		fprintf(file, \"[%s] %s\\n\", strtok(ctime(&ltime), \"\\n\"), data);\n		fclose(file);\n		return;\n}\n\nvoid consoleOP(char * data) {\n	time_t ltime;\n	time(&ltime); \n	printf(\"[%s] %s\\n\", strtok(ctime(&ltime), \"\\n\"), data);\n	return;\n}\n\nvoid killProcessOP(int signum) {\n	char strresult[250];    \n	char strTPC[30];\n	sprintf(strTPC, \"%d\", signum);\n	strcpy(strresult, \"Info: Exiting. \");\n	strcat(strresult, strTPC);\n	strcat(strresult, \" process(es) killed.\");\n	genericOP(strresult);\n	return;\n}\n\nvoid pidKilledOP(char * pidval, char * appdata, char * timeStr) {\n	char str[1000];\n	strcpy(str, \"Action: PID \");\n	strcat(str, pidval);\n	strcat(str, \" (\");\n	strcat(str, appdata);\n	strcat(str, \") killed after exceeding \");\n	strcat(str, timeStr);\n	strcat(str, \" seconds.\");\n	genericOP(str);\n	return;\n}\n\nvoid noProcessOP(char * appdata) {\n	char noProcess[150];\n	strcpy(noProcess, \"Info: No '\");\n	strcat(noProcess, appdata);\n	strcat(noProcess, \"' processes found.\");\n	genericOP(noProcess);\n	return;\n}\n\nvoid getParentPID() {\n	pid_t parent_pid = getpid();\n	parentPID = getpid();\n	printf(\"Host PID: %d\\n\", parent_pid);\n	return;\n}\n\nvoid initProcOP(char * appdata, char * pidval ) {\n	char str[1000];\n	strcpy(str, \"Info: Initializing monitoring of process '\");\n	strcat(str, appdata);\n	strcat(str, \"' (PID \");\n	strcat(str, pidval);\n	strcat(str, \").\");\n	genericOP(str);	\n	return;\n}\n\nvoid initialisationOP() {\n	char strPID[1000];\n	sprintf(strPID, \"ProcNanny initialised with PID %d.\", parentPID);\n	consoleOP(strPID);\n	return;\n}",
			"file": "src/testfork.c",
			"file_size": 10561,
			"file_write_time": 130912349843589510,
			"settings":
			{
				"buffer_size": 10536,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n\nint main()\n{\n    int pid = 0;\n\n    // create pipe pair\n    int fd[2];\n    pipe(fd);\n\n    pid = fork();\n    if (pid == 0)\n    {\n        // child side\n        char *buff = NULL;\n        char byte = 0;\n        int count = 0;\n\n        // close write side. don't need it.\n        close(fd[1]);\n\n        // read at least one byte from the pipe.\n        while (read(fd[0], &byte, 1) == 1)\n        {\n            if (ioctl(fd[0], FIONREAD, &count) != -1)\n            {\n                fprintf(stdout,\"Child: count = %d\\n\",count);\n\n                // allocate space for the byte we just read + the rest\n                //  of whatever is on the pipe.\n                buff = malloc(count+1);\n                buff[0] = byte;\n                if (read(fd[0], buff+1, count) == count)\n                    fprintf(stdout,\"Child: received \\\"%s\\\"\\n\", buff);\n                free(buff);\n            }\n            else\n            {   // could not read in-size\n                perror(\"Failed to read input size.\");\n            }\n        }\n\n        // close our side\n        close(fd[0]);\n        fprintf(stdout,\"Child: Shutting down.\\n\");\n    }\n    else\n    {   // close read size. don't need it.\n        const char msg1[] = \"Message From Parent\";\n        const char msg2[] = \"Another Message From Parent\";\n        close(fd[0]);\n        sleep(5); // simulate process wait\n        fprintf(stdout, \"Parent: sending \\\"%s\\\"\\n\", msg1);\n        write(fd[1], msg1, sizeof(msg1));\n        sleep(5); // simulate process wait\n        fprintf(stdout, \"Parent: sending \\\"%s\\\"\\n\", msg2);\n        write(fd[1], msg2, sizeof(msg2));\n        close(fd[1]);\n        fprintf(stdout,\"Parent: Shutting down.\\n\");\n    }\n    return 0;\n}",
			"settings":
			{
				"buffer_size": 1755,
				"line_ending": "Unix",
				"name": "#include <stdio.h>"
			}
		},
		{
			"contents": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n\nint main()\n{\n    int pid = 0;\n\n    // create pipe pair\n    int fd[2];\n    pipe(fd);\n\n    pid = fork();\n    if (pid == 0)\n    {\n        // child side\n        char *buff = NULL;\n        char byte = 0;\n        int count = 0;\n\n        // close write side. don't need it.\n        close(fd[1]);\n\n        // read at least one byte from the pipe.\n        while (read(fd[0], &byte, 1) == 1)\n        {\n            if (ioctl(fd[0], FIONREAD, &count) != -1)\n            {\n                fprintf(stdout,\"Child: count = %d\\n\",count);\n\n                // allocate space for the byte we just read + the rest\n                //  of whatever is on the pipe.\n                buff = malloc(count+1);\n                buff[0] = byte;\n                if (read(fd[0], buff+1, count) == count)\n                    fprintf(stdout,\"Child: received \\\"%s\\\"\\n\", buff);\n                free(buff);\n            }\n            else\n            {   // could not read in-size\n                perror(\"Failed to read input size.\");\n            }\n        }\n\n        // close our side\n        close(fd[0]);\n        fprintf(stdout,\"Child: Shutting down.\\n\");\n    }\n    else\n    {   // close read size. don't need it.\n        const char msg1[] = \"Message From Parent\";\n        const char msg2[] = \"Another Message From Parent\";\n        close(fd[0]);\n        sleep(5); // simulate process wait\n        fprintf(stdout, \"Parent: sending \\\"%s\\\"\\n\", msg1);\n        write(fd[1], msg1, sizeof(msg1));\n        sleep(5); // simulate process wait\n        fprintf(stdout, \"Parent: sending \\\"%s\\\"\\n\", msg2);\n        write(fd[1], msg2, sizeof(msg2));\n        close(fd[1]);\n        fprintf(stdout,\"Parent: Shutting down.\\n\");\n    }\n    return 0;\n}",
			"settings":
			{
				"buffer_size": 1755,
				"line_ending": "Unix",
				"name": "#include <stdio.h>"
			}
		},
		{
			"file": "ref/cppipe.c",
			"settings":
			{
				"buffer_size": 0,
				"line_ending": "Unix"
			}
		},
		{
			"file": "ref/pipe.apue.fig15.6.c",
			"settings":
			{
				"buffer_size": 2697,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "# CMPUT 291 Assignment 1 - PROCNANNY\nProcnanny is an application in which processes are monitored and killed if it exceeds a predetermined time limit. If a program exceeds its time limit, it is killed. The resulting data and information is stored within the logfile.\n\n## Name & Descriptor:\n* Anson Li, 1354766\n* Unix ID: amli\n* Lecture Section: EA1\n* Lab Section: ED04\n* TA: Soham Sinha, <soham@ualberta.ca>\n\n## How to use:\n* Delete MEMWATCH.h and MEMWATCH.c as is in the current directory system and place your own.\n* Set environment variable as export PROCNANNYLOGS=\"../tmp/logfile.txt\" ... you can test this with echo PROCNANNYLOGS. \n* Then run make.\n* Then run ./procnanny nanny.config.\n\n## Collaborators:\n* Discussed details of the project with Jake Davidson, Mohamed Salim Ben Khaled\n\n## Paths to use:\n* ../tmp/logfile.txt has the logfile data\n* ../src/ contains all the processing data\n* ../test/ contains all of the test applications. There are three in total - the sole purpose of these test applications is to be killed by the procnanny application.\n\n## Hints / notes for Assignment 2:\n* Have to pipe, then fork after the pipe is created.\n* fd[0] is always the read,\n* fd[1] is always the write.\n* We have to use this process to communicate changes; whether or not it's to check if the system is running, or to check if the system should terminate. Permanently polling system?\n* Duplicate gives you three different functions (read the manpage for dup2 for more information):\n	* if you give your file descriptor, then your duplicate will create a copy of the file descriptor with the lowest number of descriptor (file of 1).\n	* But if you use dup2(data, 0) it will duplicate your standard input...\n		* 0 is standard input.\n		* 1 is standard output.\n		* 2 is standard error.\n		* However, if the number is already in use, the program will delete the standard input and bring in the new one.\n	* This is used if the program 'thinks' its reading from standard input, but is actually read pipe information that's duplicated from the initial location ... then the program can change its settings on the fly.",
			"file": "README.md",
			"file_size": 1060,
			"file_write_time": 130904399646509422,
			"settings":
			{
				"buffer_size": 2109,
				"line_ending": "Unix"
			}
		},
		{
			"file": "ref/pipe.apue.fig15.5.c",
			"settings":
			{
				"buffer_size": 402,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/procnanny",
			"settings":
			{
				"buffer_size": 0,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/nanny.config",
			"settings":
			{
				"buffer_size": 26,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 285.0,
		"last_filter": "Package Control: i",
		"selected_items":
		[
			[
				"Package Control: i",
				"Package Control: Install Package"
			]
		],
		"width": 449.0
	},
	"console":
	{
		"height": 126.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/user/Desktop/Procnanny",
		"/home/user/Desktop/Procnanny/memwatch-2.71",
		"/home/user/Desktop/Procnanny/ref",
		"/home/user/Desktop/Procnanny/src",
		"/home/user/Desktop/Procnanny/src/node_modules",
		"/home/user/Desktop/Procnanny/tmp"
	],
	"file_history":
	[
		"/home/user/Desktop/Procnanny/ref/cppipe.c",
		"/home/user/Desktop/Procnanny/tmp/logfile.log",
		"/home/user/.config/sublime-text-3/Packages/User/Distraction Free.sublime-settings"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"int n",
			"line",
			"read",
			"fd",
			"fp",
			"shflag",
			"atoi",
			"itoa",
			"delet",
			"pidbuffer",
			"curpid",
			"OP",
			"curpid",
			"genericop",
			"str",
			"timestr",
			"writedis",
			"timevar",
			"test",
			"ai",
			"WRITEdis"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 3,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/testfork.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10536,
						"regions":
						{
						},
						"selection":
						[
							[
								7453,
								7453
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 3810.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 1,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1755,
						"regions":
						{
						},
						"selection":
						[
							[
								1755,
								1755
							]
						],
						"settings":
						{
							"auto_name": "#include <stdio.h>",
							"default_dir": "/home/user/Desktop/Procnanny/ref",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 2,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1755,
						"regions":
						{
						},
						"selection":
						[
							[
								1755,
								1755
							]
						],
						"settings":
						{
							"auto_name": "#include <stdio.h>",
							"default_dir": "/home/user/Desktop/Procnanny/ref",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 336.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "ref/cppipe.c",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 0,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "ref/pipe.apue.fig15.6.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2697,
						"regions":
						{
						},
						"selection":
						[
							[
								1517,
								1517
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 370.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "README.md",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2109,
						"regions":
						{
						},
						"selection":
						[
							[
								1897,
								1897
							]
						],
						"settings":
						{
							"syntax": "Packages/Markdown/Markdown.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 30.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "ref/pipe.apue.fig15.5.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 402,
						"regions":
						{
						},
						"selection":
						[
							[
								111,
								111
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "src/procnanny",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 0,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "src/nanny.config",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 26,
						"regions":
						{
						},
						"selection":
						[
							[
								26,
								26
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "procnanny.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
